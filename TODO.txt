* BTDF
** Transmission factor.
*** Use IOR computed from specularity.
*** Or just change specularity to IOR. Would probably make it easier to keep track of the in and out IOR's as well.
* STL loader.
* Normals revisited
** Bump mapping (Pending GL Renderer to verify winding order)
*** Filter bumpmap mipmaps using Toksvig05, SGGX or AGAA NDF construction.
** 'Fix' the normals at edges. Let the shading normal lerp towards the geometric normal at grazing angles. (Offset normal by -view_dir until the dot product is 0.)
** Offset slightly along the geometric normal as well? To avoid self shadowing and hard edges on tesselated balls.
*** Or perhaps offset along the incoming direction? That one should obviously not intersect anything else.
* Materials revisited.
** Use perfectly specular BRDFs for tiny roughness values.
*** Adapt MIS to handle specular surfaces.
** Use Fresnel between 0.6 and 0.8 for metals. Just leave diffuse on to simulate multiple scattering, but perhaps the tint should be raised to some power (3?), to simulate multiple intersections.
** GGX: Stochastically sampled diffuse term with sampling probability based on geometric term.
** Add coat.
* GL Renderer
** Half4 backbuffer in OptiXRenderer
* Multiple cameras.
** G-Buffer pr camera.
** Compose when all cameras are done.
* Screenshot
** Grab backbuffer on the CPU.
*** Request to composer or through the camera, not renderers
*** Expose certain backbuffer state pr camera/viewport in a renderer interface. Fx iteration_count, is_continuous_renderer and so on. Members that can be used to evaluate the 'doneness' of a backbuffer.
** Render to offscreen buffer.
* Multiple scenes.
** Only nodes in a certain scene should be rendered.
** Should a scene node know if it is in a scene and in which? Store the root scene ID pr node?
* Serialize scene and models.

libs
* Emscripten
* LuaJit - OpenSource (Fallback to interpretted Lua if the target architecture isn't supported.)
* OpenEXR + ZLib or TinyEXR.
