* Coated rubber/metal materials
** GGX is black with a roughness parameter of 0.
** Specular parameter.
** Metalic. Metallic metals do not use fresnel.
** Integrate into obj loader.
*** Specular amount given as average(specular color) and then lerp as is done in disneys.
** Test DefaultShading and Fresnel.
** Rewrite the events to just be a single list of materials with 'some' event. Then I can guarantee that there are no duplicates.
** Multiple importance sampling.
* Textures.
* Environment models.
* Reduce TODOs
* Notifications when changing the scene. / Pullable events.
** Camera - Create, destroy, parent changed and matrix changed. Store in bitmask pr camera instead of as separate notifications.
*** Or keep event flags pr object, then its easy to spot created and destroyed objects and if an object has had an event in general.
* Bump mapping
** Including 'fixing' the normals at edges. Let the shading normal lerp towards the geometric normal at grazing angles.
* GL Renderer
* Screenshot
** Grab backbuffer on the CPU.
*** Request to composer or through the camera, not renderers
*** Expose certain backbuffer state pr camera/viewport in a renderer interface. Fx iteration_count, is_continuous_renderer and so on. Members that can be used to evaluate the 'doneness' of a backbuffer.
** Render to offscreen buffer.
* Materials revisited.
** Application with material test scene.
*** Allow user to lerp between two materials in 10 steps, i.e. have 10 instances of the same model rendered side-by-side and then lerp the material parameters from left to right.
** Add Burley and Oren-Nayar BRDF. Burley should exclude the fresnel term, as that is part of the overall combiner.
** Add Fresnel coat. How to sample the Fresnel combiner? Add it as a coated shading model in OptiXRenderer, so I have access to both materials.
* Multiple cameras.
** G-Buffer pr camera.
** Compose when all cameras are done.
* Multiple scenes.
** Only nodes in a certain scene should be rendered.
** A scene node should know if it is in a scene and in which. Store the root scene ID pr node?
** A requirement for the asset manager to not simply add loaded nodes directly into the scene.
* Serialize scene and models.
* CUDA
** helper methods.
*** Debugging/error checking. Array management.
* -Wall? -W3?
** It's a pain now that I'm using source code instead of dlls. All my libs are being checked and produce a ton of pedantic warnings.
** However it's also nice and produce some helpful warnings, fx about struct padding (which GLFW is full of, making that warning helpful and horrible at the same time.)

Design decision
* Should I use reference counting on some/all components?
** Right now I have the issue that a Mesh could be deleted, but the MeshModel would still exists.
   All MeshModels can ofcourse check the validity of their ID's, but having ALL MeshModels check it whenever a mesh_destroyed notification exists is a bit much.
   If I use reference counting, then that problem would go away and the MeshModel would always keep the Mesh alive.

libs
* FreeImage. It has a commercial license.
* Emscripten
* LuaJit - OpenSource (Fallback to standard Lua if the target architecture isn't supported.)