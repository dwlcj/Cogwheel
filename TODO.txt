* Environment models.
** Test with sphere in 1x1 env map.
** Test TestScene and see how environments like adding and removing light sources.
** Fix environment map TODO's.
** Move environment creation into own file and create separate method for PDF and CDF computation.
** Enable decision on importance sampling environment maps if they are tiny enough. < 64 * 32 pixels? Ideally the variance in the environment is taken into acount here as well, but I doubt that I can be bothered.
** Should sampled UV have 0.5 / size added as in PBRT? Check with tiny env and compare sampled vs non-sampled diffuse material.
** Future work: Structuring the CDF as 'breath first' should improve the cache hit rate of the first couple of lookups when we do binary search or? Profile!
** Future work: Sample the environment based on cos_theta between the environment sample direction and the normal to sample more optimally compared to the total contribution of the environment. This can be achieved easily when sampling by reestimating the CDF values by cos_theta between their direction and the normal. Would it also be possible to estimate the per pixel PDF without traversing the whole acceleration structure? And how expensive is it?
**              Or can I do this by simply changing the distribution of the two random numbers before searching the CDF?
** Future work: Create a 1D CDF instead of a 2D one? Would save a bit of memory as the CDF would then take up width * height + 1 instead of height + 1 + (width + 1) * height. Are there other pros? Cons? Try it out?
* Mesh combiner.
** Combiner.
*** Combine if the materials are similar.
*** Should it just collapse a whole subgraph or should we explicitly pick a material and choose a transform+name for the new node?
*** What should we name the new nodes? '%{material name}_combined'!
*** What should their transforms be? Identity? Local identity!
** Forsyth index sorting. Lets see if it speeds up OptiX rendering. https://code.google.com/archive/p/vcacne/
** What about vertex sorting? Base it on a morton curve, order of appearance in the index array or 'clustered index array position'.
* Quaternion::look_in doesn't work for some directions, fx (0,0,1). Fix by implementing the general mat3x3 to quaternion conversion. http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
* Build prepare bat-file.
* Reduce TODOs.
** There are some in the MIS sampling.
** Precompute material parameters for DefaultShading and profile.
** Etc
* Bump mapping
** Utility function for computing tangents and normals on bump mapped surfaces. Possibly splitting the mesh.
** Including 'fixing' the normals at edges. Let the shading normal lerp towards the geometric normal at grazing angles.
** Offset slightly along the geometric normal as well? To avoid self shadowing and hard edges on tesselated balls.
*** Or perhaps offset along the incoming direction? That one should obviously not intersect anything else.
* Materials revisited.
** Is sRGB / gamma correctly handled? The X-Wing looks really dark in environments. Or am I missing a multiplication by pi? Use the sphere scene with a pure diffuse material to test it.
** Rough transmitting surfaces.
** Add Burley and Oren-Nayar BRDF. Burley should exclude the fresnel term, as that is part of the overall combiner.
** Use perfectly specular BRDFs for tiny roughness values.
*** Adapt MIS to handle specular surfaces.
** Add coat.
* GL Renderer
** Half4 backbuffer in OptiXRenderer
* Multiple cameras.
** G-Buffer pr camera.
** Compose when all cameras are done.
* Screenshot
** Grab backbuffer on the CPU.
*** Request to composer or through the camera, not renderers
*** Expose certain backbuffer state pr camera/viewport in a renderer interface. Fx iteration_count, is_continuous_renderer and so on. Members that can be used to evaluate the 'doneness' of a backbuffer.
** Render to offscreen buffer.
* Multiple scenes.
** Only nodes in a certain scene should be rendered.
** Should a scene node know if it is in a scene and in which? Store the root scene ID pr node?
* Serialize scene and models.

libs
* Emscripten
* LuaJit - OpenSource (Fallback to interpretted Lua if the target architecture isn't supported.)
* OpenEXR + ZLib or TinyEXR.
* Add ZLib and LibPNG.
** Generalize CMake source download function / macro. Found in GLFW.
