* Add Burley and Oren-Nayar BRDF.
** Compute rho for DefaultMaterial using OrenNayar and Burley. What is the max?
* Stl loader.
* Bump mapping
** Including 'fixing' the normals at edges. Let the shading normal lerp towards the geometric normal at grazing angles.
** Offset slightly along the geometric normal as well? To avoid self shadowing and hard edges on tesselated balls.
*** Or perhaps offset along the incoming direction? That one should obviously not intersect anything else.
** Utility function for computing tangents and normals on bump mapped surfaces. Possibly splitting the mesh.
* Materials revisited.
** Rough transmitting surfaces.
** Use perfectly specular BRDFs for tiny roughness values.
*** Adapt MIS to handle specular surfaces.
** GGX: Stochastically sampled diffuse term with sampling probability based on geometric term.
** Use Fresnel between 0.6 and 0.8 for metals. Just leave diffuse on to simulate multiple scattering, but perhaps the tint should be raised to some power (3?), to simulate multiple intersections.
** Add coat.
* GL Renderer
** Half4 backbuffer in OptiXRenderer
* Multiple cameras.
** G-Buffer pr camera.
** Compose when all cameras are done.
* Screenshot
** Grab backbuffer on the CPU.
*** Request to composer or through the camera, not renderers
*** Expose certain backbuffer state pr camera/viewport in a renderer interface. Fx iteration_count, is_continuous_renderer and so on. Members that can be used to evaluate the 'doneness' of a backbuffer.
** Render to offscreen buffer.
* Multiple scenes.
** Only nodes in a certain scene should be rendered.
** Should a scene node know if it is in a scene and in which? Store the root scene ID pr node?
* Serialize scene and models.

libs
* Emscripten
* LuaJit - OpenSource (Fallback to interpretted Lua if the target architecture isn't supported.)
* OpenEXR + ZLib or TinyEXR.
