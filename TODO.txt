* Warnings as errors.
* Notifications when changing the scene. / Pullable events.
** SceneNode - Create and destroy.
** Camera - Create, destroy, parent changed and matrix changed. Store in bitmask pr camera instead of as separate notifications.
** Meshes - Create and destroy.
** Models - Create and destroy.
* Point light
* Setup_for_engine(...) initializers that initializes the managers and also hooks them up to the engine.
* Materials
** Coated rubber/metal.
** Textures.
* Environment models.
* GL Renderer
* Natvis visualizations
** Natvis install target.
** Mesh, Meshes, MeshModels, SceneNodes, Cameras
** Remember to add a raw_view that will visualize the data as-is.
* Screenshot
** Grab backbuffer on the CPU.
*** Request to composer or through the camera, not renderers
*** Expose certain backbuffer state pr camera/viewport in a renderer interface. Fx iteration_count, is_continuous_renderer and so on. Members that can be used to evaluate the 'doneness' of a backbuffer.
** Render to offscreen buffer.
* Multiple cameras.
** G-Buffer pr camera.
** Compose when all cameras are done.
* Multiple scenes.
** Only nodes in a certain scene should be rendered.
** A scene node should know if it is in a scene and in which. Store the root scene ID pr node?
** A requirement for the asset manager to not simply add loaded nodes directly into the scene.
* AssetManager.
* Serialize scene and models.
* CUDA
** helper methods.
*** Debugging/error checking. Array management.
* -Wall? -W3?
** It's a pain now that I'm using source code instead of dlls. All my libs are being checked an produce a ton of pedantic warnings.
** However it's also nice and produce some helpful warnings, fx about struct padding (which GLFW is full of, making that warning helpful and horrible at the same time.)

libs
* FreeImage. It has a commercial license.
* Emscripten
* LuaJit - OpenSource (Fallback to standard Lua if the target architecture isn't supported.)